include "sciter:reactor.tis";
include "Notifications.tis";

const Status = {
	INITIAL: 0,
	LOADING: 1,
	LOADED: 2
}

function notifyApp(app, notification) {
	const messages = app.messages.slice();
	messages.push(notification);
	const update = {messages: messages};
	if (notification.name === 'DatabaseReady')
		update.status = Status.LOADED;
	app.update(update);
}

class App: Reactor.Component {
	function this(props, children) {
		this.props = props || {};
		this.children = children || {};
		this.status = Status.INITIAL;
		this.messages = [];
		this.callbackIndex = -1;
		this.notificationsContainer = null;
	}
    function render() {
		return (
			<main>
				<div id="button-initial">{this.getInitialButton()}</div>
				<div class="notifications" @{this.notificationsContainer}>{this.getMessages()}</div>
			</main>
		);
	}
	function getInitialButton() {
		if (this.status === Status.INITIAL)
			return <button :disabled={false}>Load database</button>;
		if (this.status === Status.LOADING)
			return <button :disabled={true}>Loading database ...</button>;
		if (this.status === Status.LOADED)
			return <button :disabled={false}>Display videos</button>;
	}
	function getMessages() {
		const messages = this.messages.map((message, index) => <div key={index}>{message.message}</div>);
		if (messages.length && this.status < Status.LOADED)
			messages.push(<div key={messages.length}>...</div>);
		return messages;
	}
	function attached() {
		const app = this;
		this.callbackIndex = Notifications.register(function(notification) {
			notifyApp(app, notification);
		});
	}
	function detached() {
		Notifications.unregister(this.callbackIndex);
	}
	event click $(#button-initial > button) (evt, element) {
		if (this.status === Status.INITIAL) {
			view.load_database();
			this.update({status: Status.LOADING});
			return;
		}
	}
	event contentchange $(div.notifications) (evt, element) {
	    element[element.length - 1].scrollToView(false);
	}
}
